/*
 libflamenco - lightweight and efficient software sound mixing library.
 (c) Trickster Games, 2008. Licensed under GPL license.

 Источник звука из wv-файла.
 */
#pragma once
#ifndef _FLAMENCO_INPUT_WAVPACK_H_
#define _FLAMENCO_INPUT_WAVPACK_H_

#include <wavpack/wavpack.h>

namespace flamenco
{

// Источник звука из wv-файла.
class wavpack_decoder : noncopyable
{
public:
	wavpack_decoder( std::auto_ptr<source> source );
    ~wavpack_decoder();

	// Копирует в левый и правый каналы count декодированных семплов.
	// Возвращает количество скопированных семплов, оно может быть меньше count,
	// если поток закончился.
	u32 unpack( f32 * left, f32 * right, u32 count );

	// Установка курсора начала декодирования на заданный семпл.
	void seek( u32 sample );

	// Длина потока в семплах. Функция оптимизирована для частых вызовов.
	inline u32 length() const
	{
		return mSampleCount;
	}

	// Частота звукового потока (для преобразования частоты потоком).
	inline u32 frequency() const
	{
		return mSampleRate;
	}

private:
	// Распаковывает из wavpack потока count семплов во внутренний буфер.
	// Возвращает количество прочитанных семплов
	u32 unpack_wavpack(s32 * dst, u32 size);

	// Источник данных.
	std::auto_ptr<source> mSource;

	// Частота дискретизации.
	u32 mSampleRate;
	// Длина звука в семплах.
	u32 mSampleCount;
	// Количество каналов (1 или 2).
	u32 mChannelCount;

	// Буфер для преобразования семплов из interleaved s16 в separate f32.
	s32 * mBuffer;
	// Размер буфера в семплах
	u32 mBufferSize;

	// Текущее количество семплов в буфере
	u32 mBufferRealSize;
	// Текущий семпл в буфере
	u32 mBufferOffset;

	// Входной логический поток
	WavpackContext  *mWavpackFile;
};


} // namespace flamenco

#endif // _FLAMENCO_INPUT_WAVPACK_H_
